------------------------------- problem 1 -------------------------------
button_frame = ttk.Frame(canvas, padding = 10)
canvas.create_window((0, 0), window = button_frame, anchor = "nw")
没有create_window的时候，print(canvas.bbox("all"))得到None，滚动条没有显示
有create_window的时候，print(canvas.bbox("all"))得到坐标（canvas内所有控件的边界坐标）

二者存在区别
前者只是让button_frame叠在了canvas上面
后者让button_frame真正的嵌入了canvas，使得button_frame可随着canvas动态调整
没有嵌入导致下面这决代码出问题
button_frame.bind("<Configure>", lambda event: canvas.configure(scrollregion = canvas.bbox("all")))
这句代码的意思是，使滚动条能够根据buttom_frame的大小变化而自动适应，这时有两种情况
第一种是，buttom_frame的大小真的变化了，此时滚动条会自动调整
第二种是，buttom_frame的大小没有变化，但是界面的大小变化了，此时滚动条也会自动调整
没有create_window，则canvas.bbox("all")返回None，导致设置scrollregion失败，所以滚动条没有显示
有了create_window，button_frame嵌入了canvas，canvas.bbox("all")有了返回值，设置scrollregion成功，滚动条成功显示

------------------------------- problem 2 -------------------------------
原本的想法是，输入完参数之后，点击确定按键，然后执行相应的几何变换操作，所以按键的command属性需要绑定几何变换函数
然后发现，几何变换函数都有返回值，不太适合用于command属性
所以改成了等待按键按下的操作

------------------------------- problem 3 -------------------------------
def image_translate (image_array, x_length, y_length):
    # 获取图像数组的行数和列数
    rows = image_array.shape[0]
    columns = image_array.shape[1]

    # 平移图像
    translate_result = np.zeros((rows, columns))
    for i in range(columns):
        if x_length > 0:
            if i + x_length >= columns:
                break
            translate_result[:, i + x_length] = image_array[:, i]
        elif x_length < 0:
            if i - x_length >= columns:
                break
            translate_result[:, i] = image_array[:, i - x_length]
    temp_array = translate_result
    for i in range(rows):
        if y_length > 0:
            if i + y_length >= rows:
                break
            translate_result[i + y_length, :] = temp_array[i, :]
        elif y_length < 0:
            if i - y_length >= rows:
                break
            translate_result[i, :] = temp_array[i - y_length, :]

    return translate_result

见problem3.png

temp_array = translate_result会让temp_array和translate_result共享数组空间，二者互相关联
需要使用np.copy，即temp_array = np.copy(translate_result)，使得二者相互独立
也可以考虑分别初始化两个数组temp_array和translate_result，先对temp_array操作，再根据temp_array对translate_array操作

------------------------------- problem 4 -------------------------------
在测试图像平移的时候，发现只能进行一次操作。
发现，自己必须先点一次“图像平移”按键，再输入参数，再点击“确定”按键，才能生效
如果没有点“图像平移”，直接输入参数，是不行的，这是代码设计上的问题

两种方案：
第一：
点击“确定”之后，输入参数部分消失，只有再次点击相关操作的按键，输入参数部分才会再次出现

第二：
重新设计代码

------------------------------- problem 5 -------------------------------
坐标转换的思考和理解
将点的坐标从由坐标系A描述转化到由坐标系B描述，将坐标系B转化为坐标系A，二者是等效的，或者说二者使用的变换矩阵是相同的

旋转变换推导见平板

------------------------------- problem 6 -------------------------------
旋转90度有问题，见problem6.png

------------------------------- problem 7 -------------------------------
对插值的理解有问题

我的理解：
通过坐标变换，将原始图像中某个坐标的值赋予目标图像中的某个位置
但是此时目标图像中的位置不一定是整数，所以要取整数
所以会出现目标图像中有位置没有被赋予到像素值
然后根据目标图像中的这些位置的相距最近的一系列点计算出插值
再将插值赋予目标图像中的这些刚开始没有被赋予像素值的位置

正确理解：
要先找到目标图像中某个像素的位置，在计算出在原始图像中对应的位置（一般不是整数）
找出这个小数坐标在原始图像中相距最近的一系列的点
根据某个插值公式计算得出插值
将该插值赋予目标图像中的对应位置

这就涉及到了变换方法
我采取的方法是target(trans(x, y), trans(x, y)) = src(x, y)
但是实际上较好的方式是target(x, y) = src(trans(x, y), trans(x, y))
前者容易导致目标图像像素空缺，并且不容易插值
后者保证了目标图像每一个点都会有像素值，并且易于插值

------------------------------- problem 8 -------------------------------
def image_rotate (self, angle):
    # 获取原始图像的行数和列数
    rows = self.origin_image_array.shape[0]
    columns = self.origin_image_array.shape[1]
        
    # 为了防止旋转后图像显示不全，计算新的图像数组的行数和列数
    rows_new = math.ceil(abs(rows * self.cos(angle)) + abs(columns * self.sin(angle)))
    columns_new = math.ceil(abs(rows * self.sin(angle)) + abs(columns * self.cos(angle)))

    # 原始中心点
    center_x = rows / 2
    center_y = columns / 2

    # 变换后的中心点
    center_x_new = rows_new / 2
    center_y_new = columns_new / 2

    rotate_image_array = np.zeros((rows_new, columns_new))

    # 旋转变换
    for x in range(rows_new):
        for y in range(columns):
            x_src = x * self.cos(angle) + y * self.sin(angle) - center_x_new * self.cos(angle) - center_y_new * self.sin(angle) + center_x
            y_src = -x * self.sin(angle) + y * self.cos(angle) + center_x_new * self.sin(angle) - center_y_new * self.cos(angle) + center_y
            if (x_src < 0 or x_src > rows - 1) or (y_src < 0 or y_src > columns - 1):  # 不属于原图像的部分
                rotate_image_array[x, y] = 0
            else:  # 正常情况
                x1 = int(x_src)
                x2 = math.ceil(x_src)
                y1 = int(y_src)
                y2 = math.ceil(y_src)
                rotate_image_array[x, y] = self.interpolation_method.bilinear_interpolation(x1, y1, x2, y2, 
                                                                                            self.origin_image_array[x1, y1], self.origin_image_array[x1, y2], 
                                                                                            self.origin_image_array[x2, y1], self.origin_image_array[x2, y2], 
                                                                                            x_src, y_src)
                
    return rotate_image_array
速度有点慢，没有做到观感上的立即变换完成